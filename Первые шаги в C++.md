### Вводные замечания

Первая программа
```c++
// myfirst.cpp

#include <iostream>  // директива препроцессора; здесь ТОЛЬКО объявления классов и функций, а реализации подтягиваются из библиотеки стандартных шаблонов

int main() {
  using namespace std; // это ленивый подход; доступны все имена
  // лучше использовать квалификатор std:: или объявлять `using` для обеспечения доступа только к отдельным именам 

  cout << "Come up and C++ me some time.";
  cout << endl;
  cout << "You won't regret it!" << endl;

  return 0;
}
```
NB! На практике лучше лучше использовать квалификатор `std::` (или еще говорят полные квалифицированные имена) или объявление `using` для обеспечения доступа только к отдельным именам
```c++
using std::cout;
using std::cin;
using std::endl;
...
```
NB! Заголовочный файл `iostream` включает только _объявления_ (прототипы) классов и функций, а _определения_ (реализации) подтягиваются из библиотеки стандартных шаблонов (STL); поставляются вместе с компилятором и автоматически линкуются при сборке программы.

Скомпилировать удалось такой командой
```bash
$ clang++ -std=gnu++14 -stdlib=libc++ -fcolor-diagnostics -g gurobi.cpp -o gurobi
```
NB! Здесь нужно использовать именно `clang++`, а не `clang`! Компиляция с `clang` выдает такую ошибку
```bash
Undefined symbols for architecture arm64:
  "std::__1::locale::use_facet(std::__1::locale::id&) const", referenced from:
      std::__1::ctype<char> const& std::__1::use_facet[abi:ne190102]<std::__1::ctype<char>>(std::__1::locale const&) in gurobi-8e4f3d.o
  "std::__1::ios_base::getloc() const", referenced from:
      std::__1::basic_ios<char, std::__1::char_traits<char>>::widen[abi:ne190102](char) const in gurobi-8e4f3d.o
  "std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>::__init(unsigned long, char)", referenced from:
      std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>::basic_string[abi:ne190102](unsigned long, char) in gurobi-8e4f3d.o
  "std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>::~basic_string()", referenced from:
      std::__1::ostreambuf_iterator<char, std::__1::char_traits<char>> std::__1::__pad_and_output[abi:ne190102]<char, std::__1::char_traits<char>>(std::__1::ostreambuf_iterator<char, std::__1::char_traits<char>>, char const*, char const*, char const*, std::__1::ios_base&, char) in gurobi-8e4f3d.o
      std::__1::ostreambuf_iterator<char, std::__1::char_traits<char>> std::__1::__pad_and_output[abi:ne190102]<char, std::__1::char_traits<char>>(std::__1::ostreambuf_iterator<char, std::__1::char_traits<char>>, char const*, char const*, char const*, std::__1::ios_base&, char) in gurobi-8e4f3d.o
  "std::__1::basic_ostream<char, std::__1::char_traits<char>>::put(char)", referenced from:
      std::__1::basic_ostream<char, std::__1::char_traits<char>>& std::__1::endl[abi:ne190102]<char, std::__1::char_traits<char>>(std::__1::basic_ostream<char, std::__1::char_traits<char>>&) in gurobi-8e4f3d.o
  "std::__1::basic_ostream<char, std::__1::char_traits<char>>::flush()", referenced from:
      std::__1::basic_ostream<char, std::__1::char_traits<char>>& std::__1::endl[abi:ne190102]<char, std::__1::char_traits<char>>(std::__1::basic_ostream<char, std::__1::char_traits<char>>&) in gurobi-8e4f3d.o
  "std::__1::basic_ostream<char, std::__1::char_traits<char>>::sentry::sentry(std::__1::basic_ostream<char, std::__1::char_traits<char>>&)", referenced from:
      std::__1::basic_ostream<char, std::__1::char_traits<char>>& std::__1::__put_character_sequence[abi:ne190102]<char, std::__1::char_traits<char>>(std::__1::basic_ostream<char, std::__1::char_traits<char>>&, char const*, unsigned long) in gurobi-8e4f3d.o
  "std::__1::basic_ostream<char, std::__1::char_traits<char>>::sentry::~sentry()", referenced from:
      std::__1::basic_ostream<char, std::__1::char_traits<char>>& std::__1::__put_character_sequence[abi:ne190102]<char, std::__1::char_traits<char>>(std::__1::basic_ostream<char, std::__1::char_traits<char>>&, char const*, unsigned long) in gurobi-8e4f3d.o
      std::__1::basic_ostream<char, std::__1::char_traits<char>>& std::__1::__put_character_sequence[abi:ne190102]<char, std::__1::char_traits<char>>(std::__1::basic_ostream<char, std::__1::char_traits<char>>&, char const*, unsigned long) in gurobi-8e4f3d.o
	  ...
```
Можно не использовать `using namesapce std;`, а явно указывать префикс `std`, то есть
```c++
std::cout << "...";
std::cout << std::endl;
```
В C++ можно применять вообще говоря как `printf()`, так и `scan()` и другие стандартные функции ввода-вывода языка С, которые становятся доступными благодаря включению обычного С-файла `stdio.h`, но все-таки в C++ используется `cout`
```c++
#include <stdio.h>  // For classic C printf
#include <iostream>

int main() {
    using namespace std;
	
	printf("This is test message!\n");  // Classic C
	cout << "And this is too" << endl;

    return 0;
}
```
В языке C++, в отличие от языка С, точка с запятой больше используется в качестве _терминатора_ или признака завершения, а не как разделительный знак. Разница заключается в том, что ==точка с запятой, действующая как терминатор, является частью оператора==, а не маркером между операторами. На практике в языке С++ точку с запятой никогда нельзя опускать [[Литература#^70c8d3]]<c. 52>.

В языке C++, как и в С, используется _препроцессор_. Препроцессор -- это программа, которая выполняет обработку файла исходного кода перед началом собственно компиляции. Препроцессор обрабатывает _директивы_, имена которых начинаются с символа `#`.

К примеру
```c++
#include <iostream>
```
Эта директива заставляет препроцессор добавить содержимое файла `iostream` в вашу программу.

Операцию `sizeof` можно применять к имени типа или к имени переменной. Если эта операция выполняется над именем типа, таким как `int`, то это имя должно быть заключено в круглые скобки. Для имен переменных вроде `n_short` скобки необязательны
```c++
cout << "int is " << sizeof (int) << " bytes.\n";
cout << "short is " << sizeof n_short << " bytes.\n";
```
Традиционная инициализация в C
```c
int owls = 101;
```
Альтернативный синтаксис в C++
```c++
int wrens(432); // то же, что и `int wrens = 432;`
```

Существует другой формат для инициализации, который используется с массивами и структурами, а в С++98 может также применяться с переменными, имеющими единственное значение
```c++
int value = {24}; // списковая инициализация защищает от сужающих преобрзований
```
Использование инициализатора с фигурными скобками для переменной, имеющей единственное значение, не было повсеместной практикой, но стандарт С++11 расширяет этот способ. Во-первых, такой инициализатор можно применять с или без знака `=`
```c++
int emus{7};  // то же, что и `int emus = 7;`
int rheas = {12};  // то же, что и `int rheas = 12;`
```
Во-вторых, фигурные скобки можно оставить пустыми, тогда переменная будет инициализироваться 0
```c++
int rocs = {};  // то же, что и `int rocs = 0;`
// или без =
int rocs{}; // int rocs = 0;
int psychics{};  // то же, что и `int psychics = 0;`
```
С++11 позволяет использовать синтаксис фигурных скобок (с или без знака `=`) в отношении всех типов -- он представляет собой ==универсальный синтаксис инициализации== (еще называют _списковая инициализацией_ [[Литература#^70c8d3]]<c. 122>).

==NB! Рекомендуется не оставлять переменные без инициализации, то есть всегда сразу присваивать целевое значение==
```c++
int a = 42;
```
И рекомендуется в GCC/Clang включать предупреждение компилятора `-Wall -Wextra`

В процессе компиляции исходный код передается сначала препроцессору. `#define`, как и `#include`, является _директивой препроцессора_. Эта директива сообщает препроцессору следущее: найти в программе экземпляры символической константы `INT_MAX` и заменить каждое вхождение значением `32767`. Таким образом директива `#define` работает подобно команде глобального поиска и замены в текстовом редакторе. Однако директива `#define` является пережитком языка С. В C++ имеется более удобный способ создания символических констант (с помощью ключевого слова `const`) [[Литература#^70c8d3]]<c. 92>.
### Введение в массивы

Все элементы массива храняться в памяти последовательно -- друг за другом. Создать массив можно так
```c++
short months[12];  // создает массив из 12 элементов типа short
```
В сущности каждый элемент -- это переменная, которую можно трактовать как _простую переменную_ [[Литература#^70c8d3]]<c. 132>.

==NB! Компилятор не проверяет правильность указываемого индекса. Например, компилятор не станет жаловаться, если вы присвоите значение несуществующему элементу `months[101]`. Однако такое присваивание может вызывать проблемы во время выполнения программы -- возможно, повреждение данных или кода, а может быть и аварийное завершение программы. [[Литература]]<c. 133>==

Если вы не инициализируете массив, объявленный внутри функции, его элементы остаются неопределенными. Это значит, что элементы получают случайные значения, которые зависят от предыдущего содержимого области памяти, выделенной для такого массива.
#### Правила инициализации массивов

==Можно использовать инициализацию _только_ при объявлении массивов==. Ее нельзя выполнить позже, и нельзя присваивать один массив другому
```c++
int cards[4] = {3, 6, 8, 10}; // + можно
int hand[4];                  // + можно
// а вот так нельзя!!!
hand[4] = {5, 6, 7, 9};
hand = cards;
```
При инициализации массива можно указывать меньше значений, чем в массиве объявлено элементов
```c++
float hotel_tips[5] = {5.0, 2.5};
```
Если вы инициализируете массив частично, то компилятор присваивает остальным элементам нулевые значения. Это значит, что инициализировать весь массив нулями очень легко -- для этого просто нужно явно инициализировать нулем его первый элемент, а инициализацию остальных элементов поручить компилятору
```c++
long totals[500] = {0};
```

Следует отметить, что в случае инициализации массива с применением `{1}` вместо `{0}` только первый элемент будет установлен в 1; остальные по-прежнему получат значение 0.

Если при инициализации массива оставить квадртаные скобки пустыми, то компилятор С++ самостоятельно пересчитает элементы
```c++
short things[] = {1, 5, 3, 8}; // насчитает 5 элементов!!!
```
==NB! Часто компилятор при подсчете элементов получает не то количество, которое должно быть!==
#### Инициализация массивов в C++11

В С++11 форма инициализации с фигурными скобками (списковая инициализация) стала универсальной для всех типов. Массивы уже используют списковую инциализацию, но в версии С++11 появились дополнительные возможности.

Во-первых, при инициализации массива можно отбросить знак `=`
```c++
double earnings[4] {1.2e4, 1.6e4, 1.1e4, 1.7e4}; // C++11
```
Во-вторых, можно использовать пустые фигурные скобки для установки всех элементов в 0
```c++
// C++11
unsigned int counts[10] = {};  // все элементы устанавливаются в 0
float balances[100] {};  // все элементы устанавливаются в 0
```
В-третьих, _списковая инициализация_ защищает от сужения
```c++
long plifs[] = {25, 92, 3.0}; // ERROR! double -> long
```
Преобразование из типа с плавающей точкой в целочисленный тип является ==сужением==, даже если значение с плавающей точкой содержит после десятичной точки только нули.
### Строки

Идея серии символов, сохраняемых в последовательных байтах, предполагает хранение строки в массиве `char`, где каждый элемент содержится в отдельном элементе.

Строки в стиле С обладают специальной характеристикой: последним в каждой такой строке является _нулевой символ_. Этот символ, записываемый как `\0`, представляет собой символ с ASCII-кодом 0, который служит _меткой конца строки_.
```c++
char dog[3] = {'d', 'o', 'g'};  // НЕ строка
char cat[3] = {'c', 'a', 't', '\0'}; // строка
```

В С++ существует более простой способ инициализации массива с помощью строки
```c++
char bird[] = "Mr. Cheeps"; // наличие символа \0 подразумевается
```
Строки в двойных кавычках всегда неявно включают ограничивающий нулевой символ, поэтому указывать его явно не требуется.

_Строковая константа_ (в двойных кавычках) не взаимозаменяема с _символьной константой_ (в одинарных кавычках). Символьная константа, такая как `'S'`, представляет собой сокращенное обозначение для _кода символа_. В системе ASCII константа `'S'` -- это просто другой способ записи кода 83. Поэтому следующий оператор присваивает значение 83 переменной `shirt_size` [[Литература#^70c8d3]]<c. 138>
```c++
char shirt_size = 'S'; // нормально
```

В действительности любые две строковые константы, разделенные только пробельными символами (пробелами, символами табуляции и символами новой строки), автоматически объединяются в одну
```c++
cout << "First line\n"
        "Second line\n"
		"Third line\n";
```

Подход, принятый в `cin`, заключается в использовании пробельных символов для разделения строк -- пробелов, знаков табуляции и символов новой строки. Это значит, что `cin` читает только одно слово.

К счастью, у класса `istream`, экземпляром которого является `cin`, есть функции-члены, предназначенные для строчно-ориентированного ввода: `getline()` и `get()`. Оба читают полную строку ввода -- то есть до символа новой строки. Однако `getline()` затем отбрасывает символ новой строки, в то время как `get()` оставляет его во входной очереди. 

Функция `getline()` читает целую строку, используя символ новой строки, который передан клавишей `<Enter>`, для обозначения конца ввода. Функция `cin.getline()` принимает два аргумента. Первый аргумент -- это имя места назначения (то есть массива, который сохраняет введенную строку), а второй -- максимальное количество символов, подлежащих чтению
```c++
#include <iostream>

int main() {
    const int ArSize = 20;
    char name[ArSize];
    char dessert[ArSize];

    std::cout << "Enter your name:\n";
	std::cin.getline(name, ArSize);  // читать до символа новой строки

    std::cout << "Enter your favorite dessert:\n";
	std::cin.getline(dessert, ArSize);

    std::cout << "I have some delicious " << dessert;
	std::cout << "for you, " << name << ".\n";
}
```
### Введение в класс `string`

Для работы с классом `string` в программе должен быть включен заголовочный файл `string`. Класс `string` является частью пространства имен `std`, поэтому нужно указать директиву `using` или объявление либо же ссылаться на класс как `std::string`. Определение класса скрывает природу строки как массива символов и позволяет трактовать ее как обычную переменную.
```c++
#include <iostream>
#include <string>

int main() {
   std::cout << "Enter name: ";
   std::string user_name;  // создание пустого объекта строки
   std::cin >> user_name;
   ...
```
_Объявление_ строковой переменной `std::string user_name` _создает_ строковый объект ==нулевой длины==. Но при чтении ввода в `user_name` программа автоматически его увеличивает [[Литература#^70c8d3]]<c. 147>
```c++
std::cin >> user_name;
```
NB! Класс `string` -- единая сущность, представляющая строку.
#### Инициализаця строк в С++11

С++11 позволяет осуществлять списковую инициализацию для строк в стиле С и объектов `string`
```c++
// в стиле C
char first_date[] = {"Le Chapon Dodu"};
char first_date[] {"The Elegante Plate"};
// в стиле C++
string third_date = {"The Bread Bowl"};
string forth_date {"Hank's Fine Eats"};
```
Некоторые операции со строками класс `string` выполняет проще, чем это возможно в случае символьных массивов. Например, просто присвоить один массив другому нельзя. Однако один объект `string` вполне можно присвоить другому
```c++
string str1; // создание пустого объекта строки
string str2 = "panther";  // создание инициализированной строки
str1 = str2; // МОЖНО
```
Чтобы прочитать пользовательский ввод в строковую переменную нужно воспользоваться функцией `getline()`  
```c++
#include <iostream>

int main() {
  std::cout << "Enter name: ";
  std::string user_name;  // создается пустой объект строки
  getline(std::cin, user_name);  // <- NB

  std::cout << "Name: " << user_name << std::endl;
}
```

В С++11 еще есть необработанные (сырые) строки. В такой строке символы представляют сами себя. Например, последовательность `\n` не интерпретируется как представление символа новой строки.

Таким образом, в необработанных строках в качестве разделителей применяются последовательности `"(` и `)"`, а также префикс `R` для идентификации их как необработанных строк
```c++
std::cout << R"(Hello, I'am "teacher")" << std::endl;
```
### Введние в структуры

Структура -- более универсальная форма данных, нежели массив, потому что одна структура может хранить элементы более чем одного типа. Создание структуры -- процесс, состоящий из двух частей. Вначале определяется описание структуры, в котором перечисляются и именуются типы данных, хранящиеся в структуре. Затем создаются _структурные переменные_. 
```c++
struct inflatable { // объявление структуры
  char name[20]; // члены структуры
  float valume;
  double price;
};
```
Ключевое слово `struct` указывает на то, что этот код определяет план структуры. Идентификатор `inflatable` -- имя, или _дескриптор_, этой формы, то есть имя нового типа. Таким образом, теперь можно создавать переменные типа `inflatable` точно так же, как создаются переменные типа `char` или `int`. Каждый элемент списка -- это оператор объявления. Здесь допускается использовать любые типы С++, включая массивы и другие структуры. ==Объявление структуры определяет новый тип==

==NB! Ключевое слово `struct` при объявлении структурных переменных не требуется в С++==
```c++
inflatable hat; // объявление структурной переменной
```
Использовать можно так
```c++
struct inflatable {  // объявление структуры
  char name[20];
  float volume;
  double price;
};

int main() {
  using namespace std;
  
  inflatable guest = {
    "Glorious Gloria",
    1.88,
    29.99
  };

  cout << "GUEST: " << guest.name << endl;
}
```
#### Инициализация структур в С++11

С++11 расширяет возможности списковой инициализации. Знак `=` является необязятельным
```c++
inflatable duck { // В С++11 знак = можно опустить
  "Daphne",
  0.12,
  9.98
};
```
==NB! Пустые фигурные скобки приводят к установке индивидуальных членов в 0.==
Например, следующее объявление обеспечивает установку в 0 членов `mayor.volume` и `mayor.price`, а также всех байтов в `mayor.name`
```c++
inflatable mayour {};
```
И, наконец, сужение не допускается.

Можно комбинировать определение формы структуры с созданием структурных переменных
```c++
struct perks {
  int key_number;
  char car[12];
} mr_smith, ms_jones;  // две переменные типа perks
```
Можно даже инициализировать созданную переменную
```c++
struct perks {
  int key_number;
  char car[12]; // std::string car;
} mr_glitz = {
  7,
  "Packard"
};
```
А ведь еще в C++11 можно опустить символ `=` и тогда получится
```c++
struct perks {
  int key_number;
  char car[12]; // std::string car;
} mr_glitz {
  7,
  "Packard"
};
```
Тяжело читать((

В отличие от структур С, например, структуры С++ могут включать в себя функции-члены в дополнение к переменным-членам.

Также можно создавать массивы, элементами которых являются структуры. Подход здесь в точности совпадает с таковым для массивов фундаментальных типов
```c++
inflatable gifts[10];
```
Это объявление делает `gifts` массивом структур `inflatable`. Для инициализации массива структур комбинируется правило инициализации массивов (заключенный в фигурные скобки список значений, разделенных запятыми, для каждого элемента) с правилом структур (заключенный в фигурные скобки список значений, разделенных запятыми, для каждого члена).
```c++
struct user {
  std::string name;
  std::string email;
  int profile_age;
};

user users[3] = { // инициализация массива структур
  {
    "Leor Finkelberg",
    "leor.finkelberg@yandex.ru",
    5
  },
  {
    "Alex Podvoyskiy",
    "apodvoyskiy08@gmail.com",
    3
  },
  ...
};
```
В С++11 как обычно можно убрать `=`.

Язык С++, как и С, позволяет указывать члены структур, занимающие определенное количество битов памяти. Это может пригодиться для создания структур данных, которые соответствуют, скажем, регистру в некотором аппаратном устройстве. Тип поля должен быть целочисленным или перечислимым и после него вслед за двоеточием ставится число, указывающее действительно количество байтов. Каждый член называется _битовым полем_
```c++
struct torgle_register {
  unsigned int SN : 4;
  unsigned int : 4;  // 4 бита не используется
  bool goodId : 1;
  bool goodTorgle : 1;
};
```

Эти поля можно инициализировать в обычной манере и применять стандартную нотацию структур для доступа к ним
```c++
torgle_register tr = {14, true, false};
...
if (tr.goodIn)
```
Битовые поля обычно применяются в низкоуровневом программировании.
### Объединения

_Объединения_ -- это формат данных, который может хранить в пределах одной области памяти разные типы данных, но в каждый момент времени только один из них. То есть, в то время как структура может содержать, скажем, `int`, `long` и `double`, объединение может хранить либо `int`, либо `long`, либо `double`. Синтаксис похож на синтаксис структур, но смысл отличается.
```c++
union one4all {
  int int_val;
  long long_val;
  double double_val;
};
```

Поскольку объединение хранит только одно значение в единицу времени, оно должно иметь достаточный размер, чтобы вместить самый большой член. Поэтому размер объединения определяется размером его самого большого члена
```c++
struct widget { // объявление структуры
  char brand[20];
  int type;
  union id { // объявление объединения
    long id_num;
    char id_char[20];
  } id_val;  // объявление переменной объединения
}
```
NB! В С++ (до С++20) инициализация `union` без указания поля записывает значение в первое поле, даже если, например, передается `long` . Объединение часто (но не только) используется для экономии пространства памяти. 
### Перечисление

Средство С++ `enum` представляет собой альтернативный по отношению к `const` способ создания символических констант. Он также позволяет определять новые типы, но в очень ограниченной манере. 

Оператор 
```c++
enum spectrum {
  red, orange, yellow, ...
};
```

По умолчанию перечислителям присваиваются целочисленные значения, начиная с 0 для первого из них, 1 -- для второго и т.д.

Имя перечисления можно использовать для объявления переменной с этим типом перечисления
```c++
spectrum band;  // объявление переменной типа spectrum
```

Конкретные значения элементов перечислений можно устанавливать явно посредством операции присваивания
```c++
enum bits {
  one = 1, two = 2, four = 4, eight = 8
};
```
Присваиваемые значения должны быть целочисленными. Можно также явно устанавливать только некоторые из перечислителей
```c++
enum bigstep {first, second = 100, third};
```
В этом случае `first` получает значение 0 по умолчанию. Каждый последующий неинициализированный перечислитель увеличивается на единицу по сравнению с предыдущим. Поэтому `third` имеет значение 101.

И, наконец, допускается указывать одно и то же значение для нескольких перечислителей
```c++
enum {
  zero, null = 0, one, numero_uno = 1
};
```
Здесь `zero` и `null` имеют значение 0, а `one` и `numero_uno` -- значение 1. В ранних версиях С++ элементам перечислений можно было присваивать только значения типа `int` (или неявно преобразуемые к `int`), но теперь это ограничение снято, и также можно использовать значения типа `long` или даже `long long`.

Например, предположим, что `bits` и `myflag` определены следующим образом
```c++
enum bits {
  one = 1,
  two = 2,
  four = 4,
  eight = 8
};
```
В таком случае показанный ниже оператор является допустимым
```c++
myflag = bits(6); // правильно, потому что 6 находится в пределах диапазона
```
Здесь 6 не является значением ни одного из перечислителей, однако находится в диапазоне этого определенного перечисления.

Указатель -- переменная, которая хранит адрес значения вместо самого значения. Например, если `home` -- переменная, то `&home` -- ее адрес.

NB! Следующее объявление создаст один указатель (`p1`) и одну обычную переменную типа `int` (`p2`)
```c++
int* p1, p2;  // создаст указатель int* и int
```
Знак `*` должен быть помещен возле каждой переменной типа указателя.
В языке С++ комбинация `int*` представляет составной тип "указатель на `int`".

При создании указателя в коде С++ компьютер выделяет память для хранения адреса, но не выделяет память для хранения данных, на которые указывает этот адрес [[Литература#^70c8d3]]<c. 171> 
```c++
long* fellow;  // опасно!!! 
*fellow = 223323;
```
Конечно, `fellow` -- это указатель. Но на что он указывает? Никакого адреса переменной не присвоено. Ответить на это невозможно. Поскольку переменная `fellow` не была инициализирована, ==она может иметь какое угодно значение==.

NB! Золотое правило указателей: всегда инициализируйте указатель, чтобы определить точный и правильный адрес, прежде чем применить к нему операцию разыменования (`*`) [[Литература#^70c8d3]]<c. 172>.
### Выделение памяти с помощью операции `new`

Реальная ценность указателей проявляется тогда, когда во время выполнения программы выделяются _неименованные_ области памяти для хранения значений. В этом случае указатели становятся единственным способом доступа к такой памяти. В языке С память можно выделять с помощью библиотечной функции `malloc()`. Ее можно применять и в С++, но язык С++ также предлагает лучший способ -- операцию `new`.

С помощью операции `new` можно сообщить для какого типа данных запрашивается память; `new` находит блок памяти нужного размера и возвращает его адрес
```c++
int* pn = new int;
```
Часть `new int` сообщает программе, что требуется некоторое новое хранилище, подходящее для хранения `int`. Операция `new` использует тип для того, чтобы определить, сколько байт необходимо выделить. Затем она находит память и возвращает адрес. Далее вы присваиваете адрес переменной `pn`, которая объявлена как указатель на `int`. Теперь `pn` -- адрес, а `*pn` -- значение, хранящееся по этому адресу.

NB! Выделяемая операцией `new` память, находится в области, называемой _кучей_ [[Литература#^70c8d3]]<c. 174>
### Освобождение памяти с помощью операции `delete`

Второй стороной является операция `delete`, которая позволяет вернуть память в пул свободной памяти, когда работа с ней завершена. Память, которую вы возвращаете (или _освобождаете_), затем может быть повторно использована другими частями программы. Операция `delete` применяется с указателем на блок памяти, который был выделен операцией `new`
```c++
int* ps = new int; // выделить память с помощью операции new
...                // использовать память
delete ps;         // по завершении освободить память с помощью операции delete
```

Это освобождает память, на которую указывает `ps`, но не удаляет сам указатель `ps`. Вы всегда должны обеспечивать сбалансированное применение `new` и `delete`; в противном случае вы рискуете столкнуться с таким явлением, как _утечка памяти_, то есть ситуацией, когда память выделена, но более не может быть использована. 

==NB! Вы не должны пытаться освобождать блок памяти, который уже был однажды освобожден. Стандарт С++ гласит, что результат таких попыток не определен, а это значит, что последствия могут оказаться любыми== [[Литература#^70c8d3]]<c. 175> Кроме того, вы ==не можете с помощью операции `delete` освобождать память, которая была выделена посредством объявления обычных переменных==
```c++
int* ps = new int;  // нормально
delete ps;          // нормально
delete ps;          // теперь не нормально
int jugs = 5;       // нормально
int* pi = &jugs;    // нормально
delete pi;          // не допускается, память не была выделена new
```
NB! Операция `delete` должна использоваться только для освобождения памяти, выделенной с помощью `new`. Однако применение `delete` к нулевому указателю вполне безопасно [[Литература#^70c8d3]]<c. 175>.
### Использование операции `new` для создания динамических массивов

Если все, что нужно программе -- это единственное значение, вы можете объявить обычную переменную, поскольку это намного проще, чем применение `new` для управления единственным небольшим объектом данных. 

Использование операции `new` более типично с крупными фрагментами данных, такими как массивы, строки и структуры. 

Предположим, что вы программу, которой может понадобиться массив, а может, и нет -- это зависит от информации, поступающей во время выполнения. Если вы создаете массив простым объявлением, ==пространство для него распределяется раз и навсегда== -- _во время компиляции_. Будет ли востребованным массив в программе или нет -- он все равно существует и занимает место в памяти. Распределение массива во время компиляции называется _статическим связыванием_ и означает, что массив встраивается в программу во время компиляции. 

Но с помощью `new` вы можете создать массив, когда это необходимо, _во время выполнения программы_, либо не создавать его, если потребность в нем отсутствует. Это называется _динамическим связыванием_ и означает, что массив будет создан во время выполнения программы. При динамическом связывании программа может принять решение о размере массива во время своей работы. 

Создавать динамический массив на С++ легко: вы сообщаете операции `new` тип элементов массива и требуемое количество элементов. 
```c++
int* psome = new int[10]; // получение блока памяти из 10 элементов типа int
```
Операция `new` возвращает адрес первого элемента в блоке. В данном примере это значение присваивается указателю `psome`.

Как всегда, вы должны сбалансировать каждый вызов `new` соответствующим вызовом `delete`, когда программа завершает работу с этим блоком памяти. Однако использование `new` с квадратными скобками для создания массива требует применения альтернативной формы `delete` при освобождении массива
```c++
delete [] psome; // освобождение динамического массива
```
Присутствие квадратных скобок сообщает программе, что она должна освободить весь массив, а не только один элемент, на который указывает указатель.

NB! Если вы используете `new` без скобок, то и соответствующие операции `delete`  тоже должны быть без скобок. Если же `new` со скобками, то и соответствующая операция `delete` должна быть со скобками.

При использовании `new` и `delete` необходимо придерживаться перечисленных ние правил [[Литература#^70c8d3]]<c. 177>:
- Не использовать `delete` для освобождения той памяти, которая не была выделена `new`.
- Не использовать `delete` для освобождения одного и того же блока памяти дважды.
- Использовать `delete[]` ,  если применялись операции `new[]` для размещения массива.
- Использовать `delete` без скобок, если применялись операции `new` для размещения отдельного элемента.
- Помнить о том, что применение `delete` к нулевому указателю является безопасным (при этом ничего не происходит).

Нужно обратить внимание на то, что в
```c++
int* psome = new int[10];
```
 `psome` -- это указатель на отдельное значение `int`, являющееся первым элементом блока [[Литература#^70c8d3]]<c. 177>
### Указатели, массивы и арифметика указателей

Добавление единицы к целочисленной переменной увеличивает ее значение на единицу, но добавление единицы к _переменной типа указателя_ увеличивает ее значение на количество байт, составляющих размер типа, на который она указывает. 

Добавление единицы к указателю на `double` добавляет 8 байт к числовой величине указателя на системах с 8-байтным `double`, в то время как добавление единицы к указателю на `short` добавляет к его значению 2 байта. 

Получается, что имя массива это указатель на первый элемент массива. И когда мы выводим массив на печать, выводится _адрес первого элемента массива_ [[Литература#^70c8d3]]<c. 177>
```c++
int nums[3] = {};
std::cout << nums << std::endl;      // 0x16b146ea8
std::cout << &nums[0] << std::endl;  // 0x16b146ea8
```

Пример
```c++
#include <iostream>

int main()
{
  using namespace std;

  double wages[3] = {1000.0, 2000.0, 3000.0};
  short stacks[3] = {3, 2, 1};

  double* pw = wages; // имя массива равно адресу
  short* ps = &stacks[0];

  ps = ps + 1;
  cout << "*stacks = " << *stacks << ", *(stacks + 1)" << *(stacks + 1) << std::endl;
}
```

В большинстве контекстов С++ интерпретирует _имя массива_ ==как адрес его первого элемента== [[Литература#^70c8d3]]<c. 180>
```c++
wages = &wages[0]; // адрес первого элемента массива
```

NB! Добавление единицы к переменной указателя увеличивает его значение на количество байт, представляющее размер типа, на который он указывает.

Компилятор С++ выражение `stacks[1]` трактует точно так же, как `*(stacks + 1)`. Второе выражение означает вычисление адреса второго элемента массива, и затем извлечение значения, сохраненного в нем.

NB! _Имя массива_ интерпретируется как _адрес_ первого элемента массива [[Литература#^70c8d3]]<c. 181>

NB! В С++ доступ к элементам массива всегда сводится к работе с указателями на уровне машинного кода. 

Объявление массива можно использовать для создания _массива со статическим связыванием_ -- то есть массива, размер которого ==фиксирован на этапе компиляции==
```c++
int tacos[10]; // статическое связывание, размер фиксирован во время компиляции
```
Для создания массива с динамическим связыванием (динамического массива) используется операция `new[]`. Память для этого массива выделяется в соответствии с размером, указанным во время выполнения программы
```c++
int size;
cin >> size;
int* pz = new int[size]; // динамическое связывание, размер устанавливается во время выполнения
...
delete [] pz;
```
NB! С объектом `cout`:
- имя массива `char[]`,
- указатель на `char*`,
- а также строковая константа в кавычках  `"test"`
интерпретируются как _адрес_ ==первого символа строки== [[Литература#^70c8d3]]<c. 185>

Пример
```c++
const char* bird = "wren";  // bird содержит адрес строки
```
На самом деле `"wren"` представляет собой адрес строки, поэтому приведенный выше оператор присваивает адрес `"wren"` указателю `bird`. 

Строковые литералы являются константам; именно поэтому в объявлении присутствует ключевое слово `const`. Применение  `const`, таким образом, означает, что вы можете использовать `bird` для доступа к строке, но не можете изменять ее.
### Использование операции `new` для создания динамических структур

Вы уже видели, насколько выгодным может быть создания массивов во время выполнения по сравнению с этапом компиляции. 

С помощью `new` можно создавать динамические структуры. _Динамические_ здесь снова означает ==выделение памяти== _во время выполнения_, а не _во время компиляции_ [[Литература#^70c8d3]]<c. 189>

Пример
```c++
#include <iostream>

struct user {
  std::string name;
  std::string email;
  int user_age;
  int profile_age;
};

int main() {
  user* leor_finkelberg = new user;
  
  leor_finkelberg->name = "Leor Finkelberg";
  leor_finkelberg->email = "leor.finkelberg@yandex.ru";
  leor_finkelberg->profile_age = 5;
  (*leor_finkelberg).user_age = 38;
}
```
Здесь
```c++
user* leor_finkelberg = new user;
```
присваивает указателю `leor_finkelberg` _адрес_ участка памяти достаточного размера, чтобы вместить тип `user`.

Для доступа к членам структуры через указатель, используется `->`. А еще можно разыменовать указатель на структуру и обратиться к его члену как обычно: `(*leor_finkelberg).user_age` .
### Комбинация типов

Можно создать указатель на структуру
```c++
struct atarctica_years_end {
  int year;
};

atarctica_years_end s01, s02, s03;
s01.year = 1999;

atarctica_years_end* pa = &s02;
pa->year = 2025;
```
Можно создать массив структур
```c++
atarctica_years_end trio[3]; // массив из трех структур
```
Затем с помощью операции принадлежности можно обращаться к членам какого-нибудь элемента
```c++
trio[0].year = 2003;
```
Здесь `trio` -- это массив, но `trio[0]` -- структура, и `trio[0].year` представляет собой член этой структуры. Поскольку _имя массива_ является _указателем_ [[Литература#^70c8d3]]<c. 195>, можно также применять операцию членства через указатель
```c++
(trio + 1)->year = 2004;  // то же, что и trio[1].year = 2004;
```
Можно создавать массивы указателей
```c++
const atarctica_years_end* arp[3] = {&s01, &s02, &s03};
```
Можно также создавать указатель на такой массив
```c++
const atarctica_years_end** ppa = arp;
```
Здесь `arp` представляет собой _имя массива_: следовательно, он является _адресом первого элемента в массиве_. Но его первый элемент -- указатель, поэтому `ppa` должен быть указателем на указатель на `const atarctica_years_end`, отсюда и `**`.

Это может служить примером удобства применения ключевого слова `auto` из С++11. Компилятор хорошо осведомлен о типе `arp`, поэтому он может вывести правильный тип самостоятельно
```c++
auto ppb = arp;
```
Поскольку `ppa` -- это _указатель на указатель на структуру_, `*ppa` представляет собой _указатель на структуру_
```c++
std::cout << (*ppa)->year << std::endl;
```
Так как `ppa` указывает на первый элемент массива указателей `arp`, `*ppa` является первым элементом, то есть `&s01`. Таким образом, `(*ppa)->year` -- это член `year` в структуре `s01`.
### Альтернативы массивам

Шаблонный класс `vector` похож на класс `string` в том, что он является _динамическим массивом_. Установить размер объекта `vector` можно ==во время выполнения==, и можно добавлять новые данные в конец или вставлять их в середину. В основном `vector` представляет собой альтернативу применению операции `new` для создания динамического массива. На самом деле класс `vector` использует операции `new` и `delete` для управления памятью, но делает это автоматически
```c++
#include <vector>

...
vector<int> vi; // создание массива int нулевого размера
vector<double> vd(n); // создание массива из n элементов double

// или с инициализацией
std::vector<int> ranges = {10, 20, 30}; // ДИНАМИЧЕСКИЙ массив с автоматическим управлением памятью
// или без =
std::vector<int> ranges {10, 20, 30}; // ДИНАМИЧЕСКИЙ массив с автоматическим управлением памятью
```

Если просто нужен массив фиксированного размера, то можно воспользоваться шаблонным классом `array`. Объект `array` имеет фиксированный размер и использует стек (или распределение в статической памяти) вместо свободного хранилища, поэтому он характиризуется эффективностью встроенных массивов
```c++
#include <array>
...
array<int, 5> ai;
array<double, 4> ad = {1.2, 2.1, 3.43, 4.3};
// или без =
array<double, 4> ad {1.2, 2.1, 3.43, 4.3};
```

Для того чтобы выводить булевые значения, а не числеки 0/1, нужно перед выводом добавить строку
```c++
int value = 42;
std::cout.setf(std::ios_base::boolalpha);  // NB!
std::cout << (value > 10) << std::endl; 
```

Можно использовать операции инкременте и декремента с указателями
```c++
int arr[3] = {10, 20, 30};
int* ptr = arr;

std::cout << "VALUE[0]: " << *ptr << std::endl;
std::cout << "VALUE[1]: " << *++ptr << std::endl;
```
Здесь `*++ptr` сначала выполняется инкремент указателя, а потом уже выполняется разыменование.

Если вы определяете новую переменную внутри блока, она будет существовать только во время выполнения операторов этого блока. Когда поток выполнения покидает блок, такая переменная уничтожается
```c++
#include <iostream>

int main()
{
	int x = 20;
	{
	  int y = 100;
	  std::cout << x << std::endl;
	  std::cout << y << std::endl;
	}

    std::cout << x << std::endl;
    std::cout << y << std::endl;  // ошибка во время компиляции
}
```

Чтобы создать псевдоним для типа, можно воспользоваться ключевым словом `typedef`
```c++
typedef char byte; // делает byte пседонимом для char
```

Если требуется, чтобы тело цикла выполнилось хотя бы один раз, то удобно использовать цикл do-while
```c++
...
std::string password;
const std::string CORRECT_PASSWORD = "1234";

do {
  std::cout << "Enter your password: ";
  std::cin >> password;
} while (password != CORRECT_PASSWORD);

std::cout << "Your password: " << password << std::endl;
...
```

В С++11 была добавлена новая форма цикла, которая называется циклом `for` _основанным на диапазоне_. Она упрощает одну общую задачу цикла -- делать что-то с каждым элементом массива или, в более общем случае, с одним из контейнерных классов, таким как `vector` или `array`
```c++
...
double prices[5] = {4.99, ...};

for (double elem : prices) {
  std::cout << elem << std::endl;
}
```

Для работы с форматированными строками можно использовать библиотеку `fmt` (или `std::format` в >C++20). Установить библиотеку можно из исходников так:
```bash
$ git clone https://github.com/fmtlib/fmt.git
$ cd fmt
$ mkdir build && cd build
$ cmake ..
$ make -j4
$ sudo make install  # Установка в систему
```
Установить `cmake` можно так https://gist.github.com/fscm/29fd23093221cf4d96ccfaac5a1a5c90:
```bash
$ mkdir ~/Downloads/CMake
$ curl --silent --location --retry 3 "https://github.com/Kitware/CMake/releases/download/v3.28.3/cmake-3.28.3-macos-universal.dmg" --output ~/Downloads/CMake/cmake-macos.dmg 
$ yes | PAGER=cat hdiutil attach -quiet -mountpoint /Volumes/cmake-macos ~/Downloads/CMake/cmake-macos.dmg
$ cp -R /Volumes/cmake-macos/CMake.app /Applications/
$ hdiutil detach /Volumes/cmake-macos
$ sudo "/Applications/CMake.app/Contents/bin/cmake-gui" --install=/usr/local/bin
# verify
$ cmake --version
```

Пишем тестовый файл для проверки работоспособности библиотеки `fmt` 
```c++
// test.cpp
#include <fmt/core.h>

int main() {
    fmt::print("Hello, {}!\n", "world");  // Аналог f-строки
    fmt::print("Pi ≈ {:.2f}\n", 3.141592);  // "Pi ≈ 3.14"
}
```
В корень проекта (пусть проект называется `solver`) нужно положить `CMakeLists.txt`
```bash
# CMakeLists.txt
find_package(fmt REQUIRED)
target_link_libraries(solver PRIVATE fmt::fmt)
```
Компилируем
```bash
$ clang++ -std=c++11 test.cpp -lfmt
```

Полный вариант
```bash
$ clang++ -std=gnu++14 -stdlib=libc++ -lfmt -fcolor-diagnostics -g gurobi.cpp -o gurobi -Wall
```

Например вывести элементы вектора можно так
```c++
#include <iostream>
#include <fmt/core.h>
...

int main() { 
    std::vector<float> scores {1.5, 3.8, 4.2};
    
    for (int i = 0; i < scores.size(); i++) {
        std::cout << fmt::format("score = {}", scores[i], i) << std::endl;
    }
}
```

