### Вводные замечания

Первая программа
```c++
// myfirst.cpp

#include <iostream>  // директива препроцессора; здесь ТОЛЬКО объявления классов и функций, а реализации подтягиваются из библиотеки стандартных шаблонов

int main() {
  using namespace std; // это ленивый подход; доступны все имена
  // лучше использовать квалификатор std:: или объявлять `using` для обеспечения доступа только к отдельным именам 

  cout << "Come up and C++ me some time.";
  cout << endl;
  cout << "You won't regret it!" << endl;

  return 0;
}
```
NB! На практике лучше лучше использовать квалификатор `std::` (или еще говорят полные квалифицированные имена) или объявление `using` для обеспечения доступа только к отдельным именам
```c++
using std::cout;
using std::cin;
using std::endl;
...
```
NB! Заголовочный файл `iostream` включает только _объявления_ (прототипы) классов и функций, а _определения_ (реализации) подтягиваются из библиотеки стандартных шаблонов (STL); поставляются вместе с компилятором и автоматически линкуются при сборке программы.

Скомпилировать удалось такой командой
```bash
$ clang++ -std=gnu++14 -stdlib=libc++ -fcolor-diagnostics -g gurobi.cpp -o gurobi
```
NB! Здесь нужно использовать именно `clang++`, а не `clang`! Компиляция с `clang` выдает такую ошибку
```bash
Undefined symbols for architecture arm64:
  "std::__1::locale::use_facet(std::__1::locale::id&) const", referenced from:
      std::__1::ctype<char> const& std::__1::use_facet[abi:ne190102]<std::__1::ctype<char>>(std::__1::locale const&) in gurobi-8e4f3d.o
  "std::__1::ios_base::getloc() const", referenced from:
      std::__1::basic_ios<char, std::__1::char_traits<char>>::widen[abi:ne190102](char) const in gurobi-8e4f3d.o
  "std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>::__init(unsigned long, char)", referenced from:
      std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>::basic_string[abi:ne190102](unsigned long, char) in gurobi-8e4f3d.o
  "std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>::~basic_string()", referenced from:
      std::__1::ostreambuf_iterator<char, std::__1::char_traits<char>> std::__1::__pad_and_output[abi:ne190102]<char, std::__1::char_traits<char>>(std::__1::ostreambuf_iterator<char, std::__1::char_traits<char>>, char const*, char const*, char const*, std::__1::ios_base&, char) in gurobi-8e4f3d.o
      std::__1::ostreambuf_iterator<char, std::__1::char_traits<char>> std::__1::__pad_and_output[abi:ne190102]<char, std::__1::char_traits<char>>(std::__1::ostreambuf_iterator<char, std::__1::char_traits<char>>, char const*, char const*, char const*, std::__1::ios_base&, char) in gurobi-8e4f3d.o
  "std::__1::basic_ostream<char, std::__1::char_traits<char>>::put(char)", referenced from:
      std::__1::basic_ostream<char, std::__1::char_traits<char>>& std::__1::endl[abi:ne190102]<char, std::__1::char_traits<char>>(std::__1::basic_ostream<char, std::__1::char_traits<char>>&) in gurobi-8e4f3d.o
  "std::__1::basic_ostream<char, std::__1::char_traits<char>>::flush()", referenced from:
      std::__1::basic_ostream<char, std::__1::char_traits<char>>& std::__1::endl[abi:ne190102]<char, std::__1::char_traits<char>>(std::__1::basic_ostream<char, std::__1::char_traits<char>>&) in gurobi-8e4f3d.o
  "std::__1::basic_ostream<char, std::__1::char_traits<char>>::sentry::sentry(std::__1::basic_ostream<char, std::__1::char_traits<char>>&)", referenced from:
      std::__1::basic_ostream<char, std::__1::char_traits<char>>& std::__1::__put_character_sequence[abi:ne190102]<char, std::__1::char_traits<char>>(std::__1::basic_ostream<char, std::__1::char_traits<char>>&, char const*, unsigned long) in gurobi-8e4f3d.o
  "std::__1::basic_ostream<char, std::__1::char_traits<char>>::sentry::~sentry()", referenced from:
      std::__1::basic_ostream<char, std::__1::char_traits<char>>& std::__1::__put_character_sequence[abi:ne190102]<char, std::__1::char_traits<char>>(std::__1::basic_ostream<char, std::__1::char_traits<char>>&, char const*, unsigned long) in gurobi-8e4f3d.o
      std::__1::basic_ostream<char, std::__1::char_traits<char>>& std::__1::__put_character_sequence[abi:ne190102]<char, std::__1::char_traits<char>>(std::__1::basic_ostream<char, std::__1::char_traits<char>>&, char const*, unsigned long) in gurobi-8e4f3d.o
	  ...
```
Можно не использовать `using namesapce std;`, а явно указывать префикс `std`, то есть
```c++
std::cout << "...";
std::cout << std::endl;
```
В C++ можно применять вообще говоря как `printf()`, так и `scan()` и другие стандартные функции ввода-вывода языка С, которые становятся доступными благодаря включению обычного С-файла `stdio.h`, но все-таки в C++ используется `cout`
```c++
#include <stdio.h>  // For classic C printf
#include <iostream>

int main() {
    using namespace std;
	
	printf("This is test message!\n");  // Classic C
	cout << "And this is too" << endl;

    return 0;
}
```
В языке C++, в отличие от языка С, точка с запятой больше используется в качестве _терминатора_ или признака завершения, а не как разделительный знак. Разница заключается в том, что ==точка с запятой, действующая как терминатор, является частью оператора==, а не маркером между операторами. На практике в языке С++ точку с запятой никогда нельзя опускать [[Литература#^70c8d3]]<c. 52>.

В языке C++, как и в С, используется _препроцессор_. Препроцессор -- это программа, которая выполняет обработку файла исходного кода перед началом собственно компиляции. Препроцессор обрабатывает _директивы_, имена которых начинаются с символа `#`.

К примеру
```c++
#include <iostream>
```
Эта директива заставляет препроцессор добавить содержимое файла `iostream` в вашу программу.

Операцию `sizeof` можно применять к имени типа или к имени переменной. Если эта операция выполняется над именем типа, таким как `int`, то это имя должно быть заключено в круглые скобки. Для имен переменных вроде `n_short` скобки необязательны
```c++
cout << "int is " << sizeof (int) << " bytes.\n";
cout << "short is " << sizeof n_short << " bytes.\n";
```
Традиционная инициализация в C
```c
int owls = 101;
```
Альтернативный синтаксис в C++
```c++
int wrens(432); // то же, что и `int wrens = 432;`
```

Существует другой формат для инициализации, который используется с массивами и структурами, а в С++98 может также применяться с переменными, имеющими единственное значение
```c++
int value = {24}; // списковая инициализация защищает от сужающих преобрзований
```
Использование инициализатора с фигурными скобками для переменной, имеющей единственное значение, не было повсеместной практикой, но стандарт С++11 расширяет этот способ. Во-первых, такой инициализатор можно применять с или без знака `=`
```c++
int emus{7};  // то же, что и `int emus = 7;`
int rheas = {12};  // то же, что и `int rheas = 12;`
```
Во-вторых, фигурные скобки можно оставить пустыми, тогда переменная будет инициализироваться 0
```c++
int rocs = {};  // то же, что и `int rocs = 0;`
int psychics{};  // то же, что и `int psychics = 0;`
```
С++11 позволяет использовать синтаксис фигурных скобок (с или без знака `=`) в отношении всех типов -- он представляет собой ==универсальный синтаксис инициализации== (еще называют _списковая инициализацией_ [[Литература#^70c8d3]]<c. 122>).

В процессе компиляции исходный код передается сначала препроцессору. `#define`, как и `#include`, является _директивой препроцессора_. Эта директива сообщает препроцессору следущее: найти в программе экземпляры символической константы `INT_MAX` и заменить каждое вхождение значением `32767`. Таким образом директива `#define` работает подобно команде глобального поиска и замены в текстовом редакторе. Однако директива `#define` является пережитком языка С. В C++ имеется более удобный способ создания символических констант (с помощью ключевого слова `const`) [[Литература#^70c8d3]]<c. 92>.
### Введение в массивы

Все элементы массива храняться в памяти последовательно -- друг за другом. Создать массив можно так
```c++
short months[12];  // создает массив из 12 элементов типа short
```
В сущности каждый элемент -- это переменная, которую можно трактовать как _простую переменную_ [[Литература#^70c8d3]]<c. 132>.

==NB! Компилятор не проверяет правильность указываемого индекса. Например, компилятор не станет жаловаться, если вы присвоите значение несуществующему элементу `months[101]`. Однако такое присваивание может вызывать проблемы во время выполнения программы -- возможно, повреждение данных или кода, а может быть и аварийное завершение программы. [[Литература]]<c. 133>==

Если вы не инициализируете массив, объявленный внутри функции, его элементы остаются неопределенными. Это значит, что элементы получают случайные значения, которые зависят от предыдущего содержимого области памяти, выделенной для такого массива.
#### Правила инициализации массивов

==Можно использовать инициализацию _только_ при объявлении массивов==. Ее нельзя выполнить позже, и нельзя присваивать один массив другому
```c++
int cards[4] = {3, 6, 8, 10}; // + можно
int hand[4];                  // + можно
// а вот так нельзя!!!
hand[4] = {5, 6, 7, 9};
hand = cards;
```
При инициализации массива можно указывать меньше значений, чем в массиве объявлено элементов
```c++
float hotel_tips[5] = {5.0, 2.5};
```
Если вы инициализируете массив частично, то компилятор присваивает остальным элементам нулевые значения. Это значит, что инициализировать весь массив нулями очень легко -- для этого просто нужно явно инициализировать нулем его первый элемент, а инициализацию остальных элементов поручить компилятору
```c++
long totals[500] = {0};
```

Следует отметить, что в случае инициализации массива с применением `{1}` вместо `{0}` только первый элемент будет установлен в 1; остальные по-прежнему получат значение 0.

Если при инициализации массива оставить квадртаные скобки пустыми, то компилятор С++ самостоятельно пересчитает элементы
```c++
short things[] = {1, 5, 3, 8}; // насчитает 5 элементов!!!
```
==NB! Часто компилятор при подсчете элементов получает не то количество, которое должно быть!==
#### Инициализация массивов в C++11

В С++11 форма инициализации с фигурными скобками (списковая инициализация) стала универсальной для всех типов. Массивы уже используют списковую инциализацию, но в версии С++11 появились дополнительные возможности.

Во-первых, при инициализации массива можно отбросить знак `=`
```c++
double earnings[4] {1.2e4, 1.6e4, 1.1e4, 1.7e4}; // C++11
```
Во-вторых, можно использовать пустые фигурные скобки для установки всех элементов в 0
```c++
// C++11
unsigned int counts[10] = {};  // все элементы устанавливаются в 0
float balances[100] {};  // все элементы устанавливаются в 0
```
В-третьих, _списковая инициализация_ защищает от сужения
```c++
long plifs[] = {25, 92, 3.0}; // ERROR! double -> long
```
Преобразование из типа с плавающей точкой в целочисленный тип является ==сужением==, даже если значение с плавающей точкой содержит после десятичной точки только нули.
### Строки

Идея серии символов, сохраняемых в последовательных байтах, предполагает хранение строки в массиве `char`, где каждый элемент содержится в отдельном элементе.

Строки в стиле С обладают специальной характеристикой: последним в каждой такой строке является _нулевой символ_. Этот символ, записываемый как `\0`, представляет собой символ с ASCII-кодом 0, который служит _меткой конца строки_.
```c++
char dog[3] = {'d', 'o', 'g'};  // НЕ строка
char cat[3] = {'c', 'a', 't', '\0'}; // строка
```

В С++ существует более простой способ инициализации массива с помощью строки
```c++
char bird[] = "Mr. Cheeps"; // наличие символа \0 подразумевается
```
Строки в двойных кавычках всегда неявно включают ограничивающий нулевой символ, поэтому указывать его явно не требуется.

_Строковая константа_ (в двойных кавычках) не взаимозаменяема с _символьной константой_ (в одинарных кавычках). Символьная константа, такая как `'S'`, представляет собой сокращенное обозначение для _кода символа_. В системе ASCII константа `'S'` -- это просто другой способ записи кода 83. Поэтому следующий оператор присваивает значение 83 переменной `shirt_size` [[Литература#^70c8d3]]<c. 138>
```c++
char shirt_size = 'S'; // нормально
```

В действительности любые две строковые константы, разделенные только пробельными символами (пробелами, символами табуляции и символами новой строки), автоматически объединяются в одну
```c++
cout << "First line\n"
        "Second line\n"
		"Third line\n";
```

Подход, принятый в `cin`, заключается в использовании пробельных символов для разделения строк -- пробелов, знаков табуляции и символов новой строки. Это значит, что `cin` читает только одно слово.

К счастью, у класса `istream`, экземпляром которого является `cin`, есть функции-члены, предназначенные для строчно-ориентированного ввода: `getline()` и `get()`. Оба читают полную строку ввода -- то есть до символа новой строки. Однако `getline()` затем отбрасывает символ новой строки, в то время как `get()` оставляет его во входной очереди. 

Функция `getline()` читает целую строку, используя символ новой строки, который передан клавишей `<Enter>`, для обозначения конца ввода. Функция `cin.getline()` принимает два аргумента. Первый аргумент -- это имя места назначения (то есть массива, который сохраняет введенную строку), а второй -- максимальное количество символов, подлежащих чтению
```c++
#include <iostream>

int main() {
    const int ArSize = 20;
    char name[ArSize];
    char dessert[ArSize];

    std::cout << "Enter your name:\n";
	std::cin.getline(name, ArSize);  // читать до символа новой строки

    std::cout << "Enter your favorite dessert:\n";
	std::cin.getline(dessert, ArSize);

    std::cout << "I have some delicious " << dessert;
	std::cout << "for you, " << name << ".\n";
}
```
### Введение в класс `string`

Для работы с классом `string` в программе должен быть включен заголовочный файл `string`. Класс `string` является частью пространства имен `std`, поэтому нужно указать директиву `using` или объявление либо же ссылаться на класс как `std::string`. Определение класса скрывает природу строки как массива символов и позволяет трактовать ее как обычную переменную.
```c++
#include <iostream>
#include <string>

int main() {
   std::cout << "Enter name: ";
   std::string user_name;  // создание пустого объекта строки
   std::cin >> user_name;
   ...
```
_Объявление_ строковой переменной `std::string user_name` _создает_ строковый объект ==нулевой длины==. Но при чтении ввода в `user_name` программа автоматически его увеличивает [[Литература#^70c8d3]]<c. 147>
```c++
std::cin >> user_name;
```
NB! Класс `string` -- единая сущность, представляющая строку.
#### Инициализаця строк в С++11

С++11 позволяет осуществлять списковую инициализацию для строк в стиле С и объектов `string`
```c++
// в стиле C
char first_date[] = {"Le Chapon Dodu"};
char first_date[] {"The Elegante Plate"};
// в стиле C++
string third_date = {"The Bread Bowl"};
string forth_date {"Hank's Fine Eats"};
```
Некоторые операции со строками класс `string` выполняет проще, чем это возможно в случае символьных массивов. Например, просто присвоить один массив другому нельзя. Однако один объект `string` вполне можно присвоить другому
```c++
string str1; // создание пустого объекта строки
string str2 = "panther";  // создание инициализированной строки
str1 = str2; // МОЖНО
```
Чтобы прочитать пользовательский ввод в строковую переменную нужно воспользоваться функцией `getline()`  
```c++
#include <iostream>

int main() {
  std::cout << "Enter name: ";
  std::string user_name;  // создается пустой объект строки
  getline(std::cin, user_name);  // <- NB

  std::cout << "Name: " << user_name << std::endl;
}
```

В С++11 еще есть необработанные (сырые) строки. В такой строке символы представляют сами себя. Например, последовательность `\n` не интерпретируется как представление символа новой строки.

Таким образом, в необработанных строках в качестве разделителей применяются последовательности `"(` и `)"`, а также префикс `R` для идентификации их как необработанных строк
```c++
std::cout << R"(Hello, I'am "teacher")" << std::endl;
```
### Введние в структуры

Структура -- более универсальная форма данных, нежели массив, потому что одна структура может хранить элементы более чем одного типа. Создание структуры -- процесс, состоящий из двух частей. Вначале определяется описание структуры, в котором перечисляются и именуются типы данных, хранящиеся в структуре. Затем создаются _структурные переменные_. 
```c++
struct inflatable { // объявление структуры
  char name[20]; // члены структуры
  float valume;
  double price;
};
```
Ключевое слово `struct` указывает на то, что этот код определяет план структуры. Идентификатор `inflatable` -- имя, или _дескриптор_, этой формы, то есть имя нового типа. Таким образом, теперь можно создавать переменные типа `inflatable` точно так же, как создаются переменные типа `char` или `int`. Каждый элемент списка -- это оператор объявления. Здесь допускается использовать любые типы С++, включая массивы и другие структуры. ==Объявление структуры определяет новый тип==

==NB! Ключевое слово `struct` при объявлении структурных переменных не требуется в С++==
```c++
inflatable hat; // объявление структурной переменной
```
Использовать можно так
```c++
struct inflatable {  // объявление структуры
  char name[20];
  float volume;
  double price;
};

int main() {
  using namespace std;
  
  inflatable guest = {
    "Glorious Gloria",
    1.88,
    29.99
  };

  cout << "GUEST: " << guest.name << endl;
}
```
#### Инициализация структур в С++11

С++11 расширяет возможности списковой инициализации. Знак `=` является необязятельным
```c++
inflatable duck { // В С++11 знак = можно опустить
  "Daphne",
  0.12,
  9.98
};
```
==NB! Пустые фигурные скобки приводят к установке индивидуальных членов в 0.==
Например, следующее объявление обеспечивает установку в 0 членов `mayor.volume` и `mayor.price`, а также всех байтов в `mayor.name`
```c++
inflatable mayour {};
```
И, наконец, сужение не допускается.

