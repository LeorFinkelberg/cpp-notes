Язык С++ накладывает ограничения на типы возвращаемых значений: возвращаемое значение не может быть массивом. Все остальное допускается:
- целые числа,
- числа с плавающей точкой,
- указатели и даже структуры
- и объекты. 

NB! Интересно, что хотя функция С++ не может вернуть массив непосредственно, она может вернуть его в составе структуры или объекта [[Литература#^70c8d3]]<c. 306>

Переменная, которая используется для приема переданного значения, называется _формальным параметром_. Значение, переданное функции, называется _фактическим параметром_ [[Литература#^70c8d3]]<c. 311>
### Как указатели позволяют функциям обрабатывать массивы

Язык С++ (как и С) в большинстве контекстов трактуют _имя массива_ как _указатель_. То есть _имя массива_ интерпретируется как _адрес_ его первого элемента [[Литература#^70c8d3]]<c. 318>
```c++
cookies == &cookies[0] // имя массива - это адрес его первого элемента
```

Пример вызова функции с массивом
```c++
int sum = sum_arr(cookies, ArSize);
```
Здесь `cookies` -- имя массива, поэтому, согласно правилам С++, `cookies` представляет собой _адрес первого элемента массива_. То есть функции передается _адрес_ [[Литература#^70c8d3]]<c. 318> 
```c++
int sum_arr(int* arr, int n)
```
Здесь `int* arr`  заменяет собой `int arr[]`. На самом деле оба варианта заголовка корректны, потому что в С++ нотации `int* arr` и `int arr[]` имеют идентичный смысл, когда (и только когда) применяются в _заголовке_ или _прототипе функции_. Оба варианта означают, что `arr` -- указатель на `int`.
==NB! Однако, в других контекстах нотации `int* arr` и `int arr[]` синонимами не являются== [[Литература#^70c8d3]]<c. 318>

Пример чтения из текстового файла с помощью `std::getline(file, line)`
```c++
#include <iostream>
#include <vector>
#include <array>
#include <fmt/core.h>
#include <string>
#include <fstream> // <- NB!
#include <cstdlib>


const std::string INPUT_FILENAME = "input.txt"; 

// Прототипы фукнций
int sum_arr(std::string input_filename);
int convert_string_to_int(std::string value);

int main() { 
    std::cout << "Sum of elems: " << sum_arr(INPUT_FILENAME) << std::endl;
}

// Определения функций
int sum_arr(std::string input_filename)
{
    std::ifstream in_file;
    in_file.open(input_filename);

    if (!in_file.is_open()) {
        std::cout << fmt::format("Error! File {} not found ...\n");
        exit(EXIT_FAILURE);
    }

    int total = 0;
    std::string line;
    while (std::getline(in_file, line)) { // NB! Построчное чтение из текстового файла
        total += convert_string_to_int(line);
    }
    in_file.close();

    return total;
}

int convert_string_to_int(std::string line)
{
    try {
        return std::stoi(line);
    } catch (const std::invalid_argument& err) {
        std::cerr << "Not a value: " << err.what();
    } catch (const std::out_of_range& err) {
        std::cerr << "Value too large";
    }
    __builtin_unreachable(); // Чтобы Clang++ не ругался на то, что функция типо может и не возвращать int, раз возбуждает исключение 
}
```

Иногда нужно гарантировать, что функция отображения не внесет в исходный массив никаких изменений. Такая защита обеспечивается автоматически для обычных аргументов, потому что С++ передает их по значению, и функция имеет дело с копиями. Но функция, работающая с массивом, обращается к оригиналу. Чтобы предотвратить случайное изменение содержимого массива-аргумента, при объявлении формального параметра можно применить ключевое слово `const`
```c++
void show_array(const double arr[], int n);
```
Это объявление устанавливает, что _указатель_ `arr` указывает на _константные данные_. Это значит, что использовать `arr` для изменения данных нельзя. То есть обратиться к такому значению, как `arr[0]`, можно, но изменить его не получиться. Следует отметить, что это вовсе не означает, что исходный массив должен быть константным; это значит лишь, что вы не можете использовать `arr` внутри функции для изменения данных.

Функции С++, обрабатывающие массивы, нуждаются в информации относительно типа данных, хранящихся в массиве, местоположения его начала и количества его элементов. Традиционный подход С/С++ к функциям, обрабатывающим массивы, состоит в передаче _указателя_ на начало массива в одном аргументе и размера массива -- в другом [[Литература#^70c8d3]]<c. 327>

Применять ключевое слово `const` с указателями можно двумя разными способами [[Литература#^70c8d3]]<c. 329>:
- заставить указатель указывать на _константный объект_, тем самым предотвращая модификацию объекта через указатель. 
- сделать сам указатель _константным_, запретив переустанавливать его на что-нибудь другое.

Указатель на константу
```c++
int age = 39;
const int* pt = &age;
```
NB! Такое объявление `pt` не обязательно значит, что значение, на которое он указывает, действительно является константой. Это значит лишь, что значение постоянно, когда к нему обращаются через `pt` (==то есть значение нельзя изменить через указатель==) [[Литература#^70c8d3]]<c. 329>

NB! C++ запрещает присваивание адреса константной переменной не констатному указателю [[Литература#^70c8d3]]<c. 329>

Рекомендуется объявлять формальные параметры-указатели как _указатели на_ `const` [[Литература#^70c8d3]]<c. 330>

Второй способ применения `const` делает невозможным изменение самого указателя
```c++
int sloth = 3;
const int* ps = &sloth;  // указатель на const int
int* const finger = &sloth; // const-указатель на int
```
Это объявление ограничивает `finger` только тем, что он может указывать только на `sloth` и ни на что другое.

Еще можно объявить константный указатель на константный объект
```c++
double trouble = 2.0e30
const double* const stick = &trouble;
```
Здесь `stick` может указывать только на `trouble`, и `stick` не может применяться для изменения значения `trouble`. Короче говоря, и `stick`, и `*stick` это `const`.