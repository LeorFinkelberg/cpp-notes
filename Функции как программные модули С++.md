Язык С++ накладывает ограничения на типы возвращаемых значений: возвращаемое значение не может быть массивом. Все остальное допускается:
- целые числа,
- числа с плавающей точкой,
- указатели и даже структуры
- и объекты. 

NB! Интересно, что хотя функция С++ не может вернуть массив непосредственно, она может вернуть его в составе структуры или объекта [[Литература#^70c8d3]]<c. 306>

Переменная, которая используется для приема переданного значения, называется _формальным параметром_. Значение, переданное функции, называется _фактическим параметром_ [[Литература#^70c8d3]]<c. 311>
### Как указатели позволяют функциям обрабатывать массивы

Язык С++ (как и С) в большинстве контекстов трактуют _имя массива_ как _указатель_. То есть _имя массива_ интерпретируется как _адрес_ его первого элемента [[Литература#^70c8d3]]<c. 318>
```c++
cookies == &cookies[0] // имя массива - это адрес его первого элемента
```

Пример вызова функции с массивом
```c++
int sum = sum_arr(cookies, ArSize);
```
Здесь `cookies` -- имя массива, поэтому, согласно правилам С++, `cookies` представляет собой _адрес первого элемента массива_. То есть функции передается _адрес_ [[Литература#^70c8d3]]<c. 318> 
```c++
int sum_arr(int* arr, int n)
```
Здесь `int* arr`  заменяет собой `int arr[]`. На самом деле оба варианта заголовка корректны, потому что в С++ нотации `int* arr` и `int arr[]` имеют идентичный смысл, когда (и только когда) применяются в _заголовке_ или _прототипе функции_. Оба варианта означают, что `arr` -- указатель на `int`.

