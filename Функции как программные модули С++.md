Язык С++ накладывает ограничения на типы возвращаемых значений: возвращаемое значение не может быть массивом. Все остальное допускается:
- целые числа,
- числа с плавающей точкой,
- указатели и даже структуры
- и объекты. 

NB! Интересно, что хотя функция С++ не может вернуть массив непосредственно, она может вернуть его в составе структуры или объекта [[Литература#^70c8d3]]<c. 306>

Переменная, которая используется для приема переданного значения, называется _формальным параметром_. Значение, переданное функции, называется _фактическим параметром_ [[Литература#^70c8d3]]<c. 311>
### Как указатели позволяют функциям обрабатывать массивы

Язык С++ (как и С) в большинстве контекстов трактуют _имя массива_ как _указатель_. То есть _имя массива_ интерпретируется как _адрес_ его первого элемента [[Литература#^70c8d3]]<c. 318>
```c++
cookies == &cookies[0] // имя массива - это адрес его первого элемента
```

Пример вызова функции с массивом
```c++
int sum = sum_arr(cookies, ArSize);
```
Здесь `cookies` -- имя массива, поэтому, согласно правилам С++, `cookies` представляет собой _адрес первого элемента массива_. То есть функции передается _адрес_ [[Литература#^70c8d3]]<c. 318> 
```c++
int sum_arr(int* arr, int n)
```
Здесь `int* arr`  заменяет собой `int arr[]`. На самом деле оба варианта заголовка корректны, потому что в С++ нотации `int* arr` и `int arr[]` имеют идентичный смысл, когда (и только когда) применяются в _заголовке_ или _прототипе функции_. Оба варианта означают, что `arr` -- указатель на `int`.
==NB! Однако, в других контекстах нотации `int* arr` и `int arr[]` синонимами не являются== [[Литература#^70c8d3]]<c. 318>

Пример чтения из текстового файла с помощью `std::getline(file, line)`
```c++
#include <iostream>
#include <vector>
#include <array>
#include <fmt/core.h>
#include <string>
#include <fstream> // <- NB!
#include <cstdlib>


const std::string INPUT_FILENAME = "input.txt"; 

// Прототипы фукнций
int sum_arr(std::string input_filename);
int convert_string_to_int(std::string value);

int main() { 
    std::cout << "Sum of elems: " << sum_arr(INPUT_FILENAME) << std::endl;
}

// Определения функций
int sum_arr(std::string input_filename)
{
    std::ifstream in_file;
    in_file.open(input_filename);

    if (!in_file.is_open()) {
        std::cout << fmt::format("Error! File {} not found ...\n");
        exit(EXIT_FAILURE);
    }

    int total = 0;
    std::string line;
    while (std::getline(in_file, line)) { // NB! Построчное чтение из текстового файла
        total += convert_string_to_int(line);
    }
    in_file.close();

    return total;
}

int convert_string_to_int(std::string line)
{
    try {
        return std::stoi(line);
    } catch (const std::invalid_argument& err) {
        std::cerr << "Not a value: " << err.what();
    } catch (const std::out_of_range& err) {
        std::cerr << "Value too large";
    }
    __builtin_unreachable(); // Чтобы Clang++ не ругался на то, что функция типо может и не возвращать int, раз возбуждает исключение 
}
```

Иногда нужно гарантировать, что функция отображения не внесет в исходный массив никаких изменений. Такая защита обеспечивается автоматически для обычных аргументов, потому что С++ передает их по значению, и функция имеет дело с копиями. Но функция, работающая с массивом, обращается к оригиналу. Чтобы предотвратить случайное изменение содержимого массива-аргумента, при объявлении формального параметра можно применить ключевое слово `const`
```c++
void show_array(const double arr[], int n);
```
Это объявление устанавливает, что _указатель_ `arr` указывает на _константные данные_. Это значит, что использовать `arr` для изменения данных нельзя. То есть обратиться к такому значению, как `arr[0]`, можно, но изменить его не получиться. Следует отметить, что это вовсе не означает, что исходный массив должен быть константным; это значит лишь, что вы не можете использовать `arr` внутри функции для изменения данных.

Функции С++, обрабатывающие массивы, нуждаются в информации относительно типа данных, хранящихся в массиве, местоположения его начала и количества его элементов. Традиционный подход С/С++ к функциям, обрабатывающим массивы, состоит в передаче _указателя_ на начало массива в одном аргументе и размера массива -- в другом [[Литература#^70c8d3]]<c. 327>
### Указатели и `const`

Применять ключевое слово `const` с указателями можно двумя разными способами [[Литература#^70c8d3]]<c. 329>:
- заставить указатель указывать на _константный объект_, тем самым предотвращая модификацию объекта через указатель. 
- сделать сам указатель _константным_, запретив переустанавливать его на что-нибудь другое.

Указатель на константу
```c++
int age = 39;
const int* pt = &age;
```
NB! Такое объявление `pt` не обязательно значит, что значение, на которое он указывает, действительно является константой. Это значит лишь, что значение постоянно, когда к нему обращаются через `pt` (==то есть значение нельзя изменить через указатель==) [[Литература#^70c8d3]]<c. 329>

NB! C++ запрещает присваивание адреса константной переменной не констатному указателю [[Литература#^70c8d3]]<c. 329>

Рекомендуется объявлять формальные параметры-указатели как _указатели на_ `const` [[Литература#^70c8d3]]<c. 330>

Второй способ применения `const` делает невозможным изменение самого указателя
```c++
int sloth = 3;
const int* ps = &sloth;  // указатель на const int
int* const finger = &sloth; // const-указатель на int
```
Это объявление ограничивает `finger` только тем, что он может указывать только на `sloth` и ни на что другое.

Еще можно объявить константный указатель на константный объект
```c++
double trouble = 2.0e30
const double* const stick = &trouble;
```
Здесь `stick` может указывать только на `trouble`, и `stick` не может применяться для изменения значения `trouble`. Короче говоря, и `stick`, и `*stick` это `const`.

Обычно форма указателя на `const` используется для защиты данных при передаче указателя в качестве аргумента функции.

NB! Как я понял указатель на константный объект защищает объект от изменений, но указателю можно присваивать адрес другой подходящий по типу переменной. А константный указатель разрешает изменять значение, но намертво привязан к переменной, адрес которой присваивался при объявлении указателя.
### Функции и двумерные массивы

При написании функции, которая принимает в качестве аргумента двумерный массив, необходимо помнить, что имя массива трактуется как его адрес, поэтому соответствующий формальный параметр является указателем, -- так же, как и в случае одномерного массива
```c++
int data[3][4] = {
    {1, 2, 3, 4},
    {9, 8, 7, 6},
    {2, 4, 6, 8}
};
int total = sum(data, 3);
```

Прототип функции `sum` может выглядеть так
```c++
int sum(int arr[][4], int size); // arr -- указатель, а не массив
```
Тип указателя задает количество столбцов -- вот почему количество столбцов не передается в отдельном параметре функции.
NB! Здесь в `sum()` не используется `const` в объявлении параметра `arr`, потому что эта техника предназначена для _указателей на базовые типы_, а `arr` -- это указатель на указатель [[Литература#^70c8d3]]<c. 333>
### Функции с аргументами -- строками в стиле С

Доступны 3 варианта представления строки:
- массив `char`,
- константная строка в двойных кавычках (также называемая _строковым литералом_),
- указатель на `char`, установлены в адрес начала строки.
Все три, однако, являются типом указателя на `char` (`char*`), поэтому все три варианта можно использовать в качестве аргументов функций, обрабатывающих строки
```c++
char ghost[15] = "galloping";
char* str = "galumping";
int n1 = strlen(ghost);
int n2 = strlen(str);
int n3 = strlen("gamboling");
```
Неформально вы можете сказать, что передаете строку как аргумент, но на самом деле вы передаете _адрес ее первого символа_
### Функции и структуры

Когда речь идет о структурных переменных в функциях, то структурные переменные ведут себя как базовые переменные, имеющие _единственное значение_. То есть, в отличие от массивов, структуры связывают свои значения в одиночную сущность, или объект данных, который будет трактоваться как единое целое. Можно передавать структуры по значению, но в этом случае функция будет работать _с копией исходной структуры_. 

Имя массива -- указатель на его первый элемент, но имя структуры -- это просто имя структуры, и если необходим ее адрес, то вы можете получить его с помощью операции `&` [[Литература#^70c8d3]]<c. 337>

Самый простой способ использования структуры в программе -- это трактовать ее так же, как обычные базовые типы -- то есть передавать в виде аргументов и если нужно, то использовать их в качестве возвращаемых значений [[Литература#^70c8d3]]<c. 337>

==NB! Передача структур по значению имеет наибольший смысл, когда структура относительно компактна==[[Литература#^70c8d3]]<c. 337>
### Передача адресов структур

Чтобы воспользоваться всеми преимуществами эффективности указателей, придется также возвращать указатель вместо значения. Для этого необходимо передавать функции два указателя на структуру. Первый будет указывать на преобразовываемую структуру, а а второй -- на структуру, содержащую результат преобразования. Вместо возврата новой структуры функция _модифицирует_ структуру, существующую в вызывающей функции
```c++
#include <iostream>
#include <cmath>

// Объявления структур
struct polar {
  double distance;
  double angle;
};

struct rect {
  double x;
  double y;
};

void rect_to_polar(const rect* pxy, polar* pda);
void show_polar(const polar* pda);

int main() {
  rect rplace;
  polar pplace;
  std::cout << "Enter the x and y values: ";
  while (std::cin >> rplace.x >> rplace.y) {
    rect_to_polar(&rplace, &pplace); // передача АДРЕСОВ структур
	show_polar(&pplace); // передача АДРЕСА структуры
	
	std::cout << "Next two numbers (q to quit): ";
  }
  std::cout << "Done.\n";
}

void show_polar(const polar* pda) {
  const double RAD_TO_DEG = 57.29577951;
  std::cout << "distance = " << pda->distance;
  std::cout << ", angle = " << pda->angle * RAD_TO_DEG;
  std::cout << " degrees\n";
}

void rect_to_polar(const rect* pxy, polar* pda) {
  pda->distance = sqrt(pxy->x * pxy->x + pxy->y * pxy->y);
  pda->angle = atan2(pxy->y, pxy->x);
}
```