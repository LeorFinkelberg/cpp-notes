_Встроенные функции_ являются усовершенствованием языка С++, предназначенным для ускорения работы программ.
### Ссылочные переменные

Язык С++ вводит в практику новый составной тип данных -- _ссылочную переменную_. _Ссылка_ представляет собой имя, которое является псведонимом, или альтернативным именем, для ранее объявленной переменной.

Например, если вы делаете `twain` ссылкой на переменную `clemens`, можно взаимозаменяемо использовать эти имена для представления данной переменной. Основное назначение ссылок -- использование в качестве формальных аргументов функций. Применяя ссылку, функция работает с исходными данными, а не с их копиями. _Ссылки_ представляют собой удобную альтернативу указателям при обработке крупных структур посредством функций
```c++
int rats;
int& rodents = rats; // int& -- ссылка на int
```
В таком контексте символ `&` не является операцией взятия адреса. В этом случае `&` воспринимается как часть идентификатора типа данных. Они ссылаются на одно и тоже _значение_, а также на один и тот же _адрес памяти_ [[Литература#^70c8d3]]<c. 371>

NB! Ссылку необходимо инициализировать в момент ее объявления [[Литература#^70c8d3]]<c. 373>

Ссылка скорее похожа на указатель `const`; ее следует инициализировать в момент создания, и она остается привязанной к определенной переменной до конца программы. Таким образом, конструкция
```c++
int& rodents = rats;
```
по сути, является замаскированной записью выражения
```c++
int* const pr = &rats;
```
В данном случае ссылка `rodents` играет ту же роль, что и выражение `*pr`.

Ссылку можно устанавливать с помощью инициализирующего объявления, но не операцией присваивания
```c++
int rats = 101;
int* pt = &rats;
int& rodents = *pt; // int* const rodents = &(*pt);
int bunnies = 50;
pt = &bunnies;

std::cout << *pt << std::endl; // 50
std::cout << rodents << std::endl; // 101
```
Инициализация `rodents` в `*pt` приводит к тому, что `rodents` ссылается на `rats`. Последующая попытка изменения `pt` с целью указания на `bunnies` не отменяет того факта, что `rodents` ссылается на `rats`.
### Ссылки как параметры функции

Чаще всего ссылки используются как параметры функции, при этом имя переменной становится _псевдонимом_ переменной в вызывающей программе. Такой метод передачи аргументов называется _передачей по ссылке_. 

Пример [[Литература#^70c8d3]]<c. 374>
- передача по значению
```c++
// ПЕРЕДАЧА ПО ЗНАЧЕНИЮ
...
// prototypes
void sneezy(int);

int main()
{
  int times = 20; // создается переменная times со значением 20
  sneezy(times);
  ...
}

// defs
void sneezy(int x)
{
  // создается переменная x со значением 20
  ...
}
```
- передача по ссылке
```c++
// ПЕРЕДАЧА ПО ССЫЛКЕ
...
// prototypes
void grumpy(int&);

int main()
{
  int times = 20; // создает переменную times со значением 20
  grumpy(times);
}

// defs
void grumpy(int& x)
{
  // делает x псевдонимом для times
  ...
}
```

В языке С ограничение передачи аргументов по значению можно обойти за счет применения указателей.

Постоянную ссылку можно объявить с помощью квалификатора `const`
```c++
double refcube(const double& ra);
```
Ссылочные аргументы полезно применять для более крупных элементов данных, таких как структуры и классы.

NB! Если передаваемый функции аргумент не является lvalue или не совместим по типу с соответствующим ссылочным параметром `const`, C++ создает анонимную переменную требуемого типа, присваивает ей значение передаваемого функции аргумента, и делает так, чтобы параметр ссылался на эту переменную [[Литература#^70c8d3]]<c. 380>

Существует три серьезных причины объявлять ссылочные аргументы как ссылки на константные данные:
- использование `const` защищает от внесения в программы ошибок, приводящих к непреднамеренному изменению данных.
- использование `const` позволяет функции обрабатывать фактические аргументы как `const`, так и без `const`. При этом функция, в прототипе которой квалификатор `const` опущен, может принимать только неконстантные данные.
- использование ссылки `const` позволяет функции генерировать и использовать временные переменные по мере необходимости.
Формальные ссылочные аргументы рекомендуется объявлять с квалификатором `const` во всех случаях, когда для этого есть возможность [[Литература#^70c8d3]]<c. 381>.

Ссылки на структуру в качестве параметра функции ничем не отличается от метода применения ссылки на базовую переменную: при объявлении параметра структуры достаточно воспользоваться операцией ссылки `&`
```c++
struct free_throws
{
  std::string name;
  int made;
  int attemps;
  float percent;
};
```
Затем функция, использующая ссылку на этот тип, может иметь такой прототип
```c++
void set_pc(free_throws& ft); // использование ссылки на структуру
``` 
Если функция не должна изменять структуру, необходимо применять `const`
```c++
void display(const free_throws& ft); // не разрешать изменения структуры
```

Структуру можно передать по значению, однако использование ссылки более экономично с точки зрения времени и памяти, чем создание копии исходной структуры.

Выражение, следующее за `return`, вычисляется, и полученное значение передается обратно вызывающей функции. Концептуально это значение _копируется_ во временную ячейку и вызывающая программа его использует.

Рассмотрим следующий оператор
```c++
dup = accumulate(team, five);
```

Если `accumulate()` будет возвращать ==структуру вместо ссылки на структуру==, это может повлечь за собой ==копирование целой структуры== во _временную ячейку_ и ==последующее копирование== этой копии в `dup`. Но благодаря ссылочному возвращаемому значению, `team` копируется напрямую в `dup`, что является более эффективным подходом [[Литература#^70c8d3]]<c. 386>.

NB! Функция, которая возвращает ссылку, фактически является _псевдонимом_ переменной, на которую ссылается [[Литература#^70c8d3]]<c. 386>

Пример
```c++
double m = sqrt(16.0); // 4.0 -> temp -> m
```
Здесь вычисленное значение (4.0) ==копируется== во _временную ячейку_, после чего значение из этой ячейки ==копируется== в `m` [[Литература#^70c8d3]]<c. 385>

NB! Через _ссылку_ можно изменять значения!
```c++
int value = 42;
int& value_ref = value; // value_ref -- это ссылка (псевдоним)

std::cout << value << std::endl; // 42

value_ref = 100; // изменяем значение через ссылку
std::cout << value << std::endl; // 100
```

NB! Возврат ссылки на локальную переменную -- серьезная ошибка! [[Литература#^70c8d3]]<c. 391>
```c++
const std::string& version3(std::string& s1, const std::string& s2)
{
  std::string temp;
  temp = s2 + s1 + s2;

  return temp;
}

int main()
{
  result = version3(input, "@@@"); // ОШИБКА!!!
}
```
==Попытка ссылки на память, которая больше не используется!==

NB! _Возвращаемое значение функции_ храниться во _временной ячейке памяти_, которая не обязательно будет существовать на момент выполнения следующего оператора [[Литература#^70c8d3]]<c. 387>

Есть две главных причины использовать ссылочные аргументы [[Литература]]<c. 394>:
- чтобы позволить изменять объект данных в вызывающей функции,
- чтобы ускорить работу программы за счет передачи ссылки вместо полной копии объекта данных (структуры, объекты классов).
По этим же двум причинам в качестве аргумента может использоваться _указатель_. Это оправдано, посколько аргументы-ссылки, по сути, являются лишь альтернативным интерфейсом для кода, где применяются указатели.
### Аргументы по умолчаню

_Аргумент по умолчанию_ представляет собой значение, которое используется автоматически, если соответсвующий фактический параметр в вызове функции не указан. 

Для того чтобы установить значение по умолчанию, применяется прототип функции. Поскольку компилятор использует прототип, чтобы узнать, сколько аргументов имеет функция, прототип функции также должен сообщать программе о возможности наличия аргументов по умолчанию [[Литература#^70c8d3]]<c. 395> Метод заключается в присваивании значения аргументу в самом прототипе
```c++
char* left(const char* str, int n = 1);
```

